<!DOCTYPE html>
<html>
<head>
 <link rel="stylesheet" type="text/css" href="theme.css"/> 
<title>Help-R</title>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous"/>
  <link href='https://fonts.googleapis.com/css?family=Roboto:300,400,700' rel='stylesheet' type='text/css'/>

  
   <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<script src="babylon.objFileLoader.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>

    <!-- <script src="three.js"></script> -->
    <!-- <script src="Detector.js"></script> -->
    <!-- <script src="OrbitControls.js"></script> -->
    <!-- <script src="OBJLoader.js"></script> -->
    <!-- <script src="MTLLoader.js"></script> -->
	    <style>
        html, body {
            width   : 100%;
            height  : 100%;
            margin  : 0;
            padding : 0;
        }

        #renderCanvas {
            width   : 100%;
            height  : 100%;
            touch-action: none;
        }
    </style>

	

<script src="script.js"></script>
</head>
<body>
<header class="container">
       <div class="row">   
       <h1 class="col-sm-4">Help-R</h1>
       <nav class= "col-sm-8 text-right">
         <p ><a href="index.html" style="text-decoration:none;"> Romana</a></p>
         <p ><a href="indexe.html" style="text-decoration:none;">English</a></p>
       </nav>
       </div>
   </header>
  <section class="jumbotron">
    <div class="container">
      <div class="row text-center">
        <h1>Echipa Help-R</h1>
      </div>
    </div>
  </section>
<div class="container-fluid"> 
  <div class="row text-center">
	<h2>Construim un robot care sa gaseasca persoane blocate intr-o salina(Help) si sa cerceteze(R-research). Acest robot este controlat de la distanta si transmite video si audio,explorand spatiile greu accesibile oamenilor, colectand mostre de sol si 
	masurand parametrii fizico-chimici ai mediului cercetat pentru a stabili daca este propice vietii(pH-ul apei,diferenta de altitudine,prezenta gazelor toxice/ a oxigenului, prezenta radiatiilor, a vibratiilor)
	,cauta fiinte aflate in dificultate , ofera un minim prim ajutor (trusa medicala) si transmite toate datele catre statia de comanda, pentru a fi analizate.</h2>
  </div>
  <div class="row"
<br>
 <hr size="30"> 
<br>
  </div>
 <div class="row-fluid">
  <div class="col-md-2">
		<img src="untitled.png" class="img-rounded" alt="untitledhlpr" width="180" height="180">
	</div>
   <div class="col-md-10">
		<br>
		<br>
		<h2>               Echipa noastra este formata din patru elevi:<h2>
   </div>
 </div>
  <div class="row-fluid">
	<div class="col-md-2"
	<p>Vlad Logyin<p>
	<p>Clasa a 10-a</p>
	<p>CNMB</p>
	</div>
	<div class="col-md-2"
	<p>Simina Dinu<p>
	<p>Clasa a 10-a</p>
	<p>CNMB</p>
	</div>
	<div class="col-md-2"
	<p>Sebastian Severin<p>
	<p>Clasa a 10-a</p>
	<p>CNMB</p>
	</div>
	<div class="col-md-2"
	<p>Popescu Cezar Gabriel<p>
	<p>Clasa a 9-a</p>
	<p>Liceul Ovidius</p>
	</div>
  </div>
</div>
  <br><br>
  <div class='row'><div class='span12'>
<hr style="width: 100%; color: #e5e5e5 height: 2px; background-color:black;" />
  </div></div>
  <br>

<div class="row text-center">
	<h2>Model 3d ce reprezinta robotul nostru pana acum:</h2><br>
</div>
<script src="../build/three.js"></script>
<script src="js/loaders/OBJLoader.js"></script>

		<script>
//
//        if (!Detector.webgl) {
//            Detector.addGetWebGLMessage();
//        }
//
//       var container;
//
//        var camera, controls, scene, renderer;
//     var lighting, ambient, keyLight, fillLight, backLight;
//
//      var windowHalfX = window.innerWidth / 2;
//      var windowHalfY = window.innerHeight / 2;
//
//      init();
//      animate();
//
//      function init() {
//
//          container = document.createElement('div');
//          document.body.appendChild(container);
//
//          /* Camera */
//
//          camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
//          camera.position.z = 3;
//
//          /* Scene */
//
//          scene = new THREE.Scene();
//          lighting = true;
//
//          ambient = new THREE.AmbientLight(0xffffff, 1.0);
//          scene.add(ambient);
//
//          keyLight = new THREE.DirectionalLight(new THREE.Color('hsl(30, 100%, 75%)'), 1.0);
//          keyLight.position.set(-100, 0, 100);
//
//          fillLight = new THREE.DirectionalLight(new THREE.Color('hsl(240, 100%, 75%)'), 0.75);
//          fillLight.position.set(100, 0, 100);
//
//          backLight = new THREE.DirectionalLight(0xffffff, 1.0);
//          backLight.position.set(100, 0, -100).normalize();
//		
//		        ambient.intensity = 0.25;
//                  scene.add(keyLight);
//                  scene.add(fillLight);
//                  scene.add(backLight);
//          /* Model */
//
//          var mtlLoader = new THREE.MTLLoader();
//          mtlLoader.setBaseUrl('assets/');
//          mtlLoader.setPath('assets/');
//          mtlLoader.load('h.mtl', function (materials) {
//
//              materials.preload();
//
//              materials.materials.default.map.magFilter = THREE.NearestFilter;
//              materials.materials.default.map.minFilter = THREE.LinearFilter;
//
//              var objLoader = new THREE.OBJLoader();
//              objLoader.setMaterials(materials);
//              objLoader.setPath('assets/');
//              objLoader.load('rover2asamblat.obj', function (object) {
//
//                  scene.add(object);
//
//              });
//
//          });
//
//          /* Renderer */
//
//          renderer = new THREE.WebGLRenderer();
//          renderer.setPixelRatio(window.devicePixelRatio);
//          renderer.setSize(window.innerWidth, window.innerHeight);
//          renderer.setClearColor(new THREE.Color("hsl(0, 0%, 10%)"));
//
//          container.appendChild(renderer.domElement);
//
//          /* Controls */
//
//          controls = new THREE.OrbitControls(camera, renderer.domElement);
//          controls.enableDamping = true;
//          controls.dampingFactor = 0.25;
//          controls.enableZoom = false;
//
//          /* Events */
//
//          window.addEventListener('resize', onWindowResize, false);
//          window.addEventListener('keydown', onKeyboardEvent, false);
//
//      }
//
//      function onWindowResize() {
//
//          windowHalfX = window.innerWidth / 2;
//          windowHalfY = window.innerHeight / 2;
//
//          camera.aspect = window.innerWidth / window.innerHeight;
//          camera.updateProjectionMatrix();
//
//          renderer.setSize(window.innerWidth, window.innerHeight);
//
//      }
//
//      function onKeyboardEvent(e) {
//
//          if (e.code === 'KeyL') {
//
//              lighting = !lighting;
//
//              if (lighting) {
//
//                  ambient.intensity = 0.25;
//                  scene.add(keyLight);
//                  scene.add(fillLight);
//                  scene.add(backLight);
//
//              } /*else {
//
//                  ambient.intensity = 0.7;
//                  scene.remove(keyLight);
//                  scene.remove(fillLight);
//                  scene.remove(backLight);
//
//              }*/
//
//          }
//
//      }
//
//      function animate() {
//
//          requestAnimationFrame(animate);
//
//          controls.update();
//
//          render();
//
//      }
//
//      function render() {
//
//          renderer.render(scene, camera);
//
//      }
//
//  </script>
  <canvas id="renderCanvas"></canvas>
    <script>
        window.addEventListener('DOMContentLoaded', function(){
            // get the canvas DOM element
            var canvas = document.getElementById('renderCanvas');

            // load the 3D engine
            var engine = new BABYLON.Engine(canvas, true);

            // createScene function that creates and return the scene
var createScene = function () {
    var scene = new BABYLON.Scene(engine);
	var meshmodel = new BABYLON.AbstractMesh('CurrModel', scene);
	var timeoutID;
	var clicked = false;
    var currentPosition = { x: 0, y: 0 };
    var currentRotation = { x: 0, y: 0 };
	//variables to set last angle and curr angle in each frame
	//so we can calculate angleDiff and use it for inertia
	var lastAngleDiff = { x: 0, y: 0 };
	var oldAngle = { x: 0, y: 0 };
	var newAngle = { x: 0, y: 0 };
	//variable to check whether mouse is moved or not in each frame
	var mousemov = false;
	//framecount reset and max framecount(secs) for inertia
	var framecount = 0;
	var mxframecount = 120; //4 secs at 60 fps
	
	scene.beforeRender = function () {
		//set mousemov as false everytime before the rendering a frame
		mousemov = false;
	}

	scene.afterRender = function () { 
		//we are checking if the mouse is moved after the rendering a frame
		//will return false if the mouse is not moved in the last frame
		//possible drop of 1 frame of animation, which will not be noticed 
		//by the user most of the time
		if (!mousemov && framecount <mxframecount) {
			//console.log(lastAngleDiff);
			//divide the lastAngleDiff to slow or ease the animation
			lastAngleDiff.x = lastAngleDiff.x / 1.1;
			lastAngleDiff.y = lastAngleDiff.y / 1.1;
			//apply the rotation
			meshmodel.rotation.x += lastAngleDiff.x;
			meshmodel.rotation.y += lastAngleDiff.y
			//increase the framecount by 1
			//this doesnt make sense right now as it resets
			//after reaching max and continues in the loop
			//thinking of a way to fix it
			framecount++;
			currentRotation.x = meshmodel.rotation.x;
            currentRotation.y = meshmodel.rotation.y;
		} else if(framecount>=mxframecount) {
			framecount = 0;
		}
	};
	
    //Adding a light
   // var light = new BABYLON.PointLight("Omni", new BABYLON.Vector3(20, 20, 100), scene);
	var light = new BABYLON.DirectionalLight("DirectionalLight", new BABYLON.Vector3(0, -1, 0), scene);

    //Adding an Arc Rotate Camera
    var camera = new BABYLON.ArcRotateCamera("Camera", 0, 0.8, 100, BABYLON.Vector3.Zero(), scene);
	camera.attachControl(canvas, false);
	camera.fov -= 0.4;  
    // The first parameter can be used to specify which mesh to import. Here we import all meshes
    BABYLON.SceneLoader.ImportMesh("", "./", "r5.babylon", scene, function (newMeshes) {
        // Set the target of the camera to the first imported mesh
        camera.target = newMeshes[0];
		meshmodel = newMeshes[0];
    });

    canvas.addEventListener("pointerdown", function (evt) {
                currentPosition.x = evt.clientX;
                currentPosition.y = evt.clientY;
                currentRotation.x = meshmodel.rotation.x;
                currentRotation.y = meshmodel.rotation.y;
                clicked = true;
				console.log(canvas);
    });

    canvas.addEventListener("pointermove", function (evt) {
		
		if (clicked) {
			//set mousemov as true if the pointer is still down and moved
			mousemov = true;
		}
        if (!clicked) {
            return;
        }
		//set last angle before changing the rotation
		oldAngle.x = meshmodel.rotation.x;
		oldAngle.y = meshmodel.rotation.y;
		//rotate the mesh
        meshmodel.rotation.y -= (evt.clientX - currentPosition.x) / 300.0;
        meshmodel.rotation.x -= (evt.clientY - currentPosition.y) / 300.0;
		//set the current angle after the rotation
		newAngle.x = meshmodel.rotation.x;
		newAngle.y = meshmodel.rotation.y;
		//calculate the anglediff
		lastAngleDiff.x = newAngle.x - oldAngle.x;
		lastAngleDiff.y = newAngle.y - oldAngle.y;
		currentPosition.x = evt.clientX;
		currentPosition.y = evt.clientY;
    });
	
    canvas.addEventListener("pointerup", function (evt) {
        clicked = false;
    });
    // Move the light with the camera
    scene.registerBeforeRender(function () {
        light.position = camera.position;
    });
	scene.activeCamera = camera;scene.activeCamera.attachControl(canvas);	
    return scene;
}
		
       // Zeichne
       engine.runRenderLoop(function () {
           scene.render();
       });

       // Resize
       window.addEventListener("resize", function () {
           engine.resize();
       });
            // call the createScene function
            var scene = createScene();

            // run the render loop
            engine.runRenderLoop(function(){
                scene.render();
            });

            // the canvas/window resize event handler
            window.addEventListener('resize', function(){
                engine.resize();
            });
        });
    </script>
  
  
  
  
  <footer class="container">
    <div class="row">
	 <div class="col-md-9"> </div>
	 
      <p class="col-md-3"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	  Site creat de Popescu Cezar Gabriel </p>
	 
    </div>
    
  </footer>

</body>
</html>
